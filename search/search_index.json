{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to package_name documentation!","text":"<p>This is template for documenting a Python package. It follows the Di\u00e1taxis framework layout and includes a section for Architectural Decision Records (ADRs) and an auto-generated API reference.</p>"},{"location":"#package_name","title":"<code>package_name</code>","text":"<p>A Python project template.</p>"},{"location":"tags/","title":"Tags","text":""},{"location":"tags/#tag:docs","title":"docs","text":"<ul> <li>            ADR-001: Use Architectural Decision Records          </li> </ul>"},{"location":"tags/#tag:packaging","title":"packaging","text":"<ul> <li>            ADR-002: Manage dependencies with uv          </li> </ul>"},{"location":"architecture/","title":"Architecture","text":"<ul> <li>Architectural Decision Records (ADRs)</li> </ul>"},{"location":"architecture/adr/","title":"Architectural Decision Records","text":"ADR Status Summary ADR-001: Use Architecture Decision Records \ud83d\udfe2 Accepted Use ADRs to explain the rationale behind architecturally significant design choices for future developers and AI assistants ADR-002: Manage dependencies with uv \ud83d\udfe2 Accepted Use uv to manage project dependencies"},{"location":"architecture/adr/001-use-architectural-decision-records/","title":"ADR-001: Use Architectural Decision Records","text":"Status \ud83d\udfe2 Accepted Created 2025-10-12 Last Updated 2025-10-12 Deciders Gemma Danks","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#context","title":"Context","text":"<p>Architectural decisions are design choices that have a significant impact on one or more architecture qualities (e.g. modifiability, maintainability, observability, testability, scalability, interoperability, extensibility, portability). These decisions shape both the current state of a project and its long-term trajectory. Over time, the rationale for these decisions can get lost if they are not written down. One certainty in software development is that there will at some point be a need, or a desire, to change and adapt to new requirements, technologies and best practices.</p> <p>Without knowing why a decision was made, there is a risk that future developers will not feel empowered to make changes. This will lead to the accumulation of technical debt when working around the current architecture in the short-term and, in the long-term, will make the project obsolete. Conversely, there may be a very good reason for sticking to the original decision but if future developers are not aware of this reason they may make changes that must later be reverted, wasting time and effort. Nygard refers to these two alternatives as \"blind acceptance\" and \"blind reversal\" in a 2011 blog post on documenting architectural decisions, which we recommend reading for additional context.</p> <p>Another force to consider, at the time of writing in 2025, is the rapid adoption of AI tools for software development. A future developer may defer to an AI coding assistant or agent to recommend changes. Unless there is an AI-readable record of the rationale for earlier decisions, these tools are more likely to recommend reversing those they see as suboptimal. If this record exists, however, AI can be used more effectively to evolve a project and help onboard new developers (e.g. by providing summaries, answering questions and explaining the rationale behind certain choices).</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#problem-statement","title":"Problem Statement","text":"<p>How do we share the rationale for architectural decisions with future human or AI developers so that they can make more informed choices that ensure the continuity and evolvability of the project?</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#options-considered","title":"Options Considered","text":"Option Description Maintainability Knowledge Retention Traceability AI Usability Effort Discoverability Overall score Notes Weight - 1 2 1 1 1 1 - ADR Architectural Decision Record \u2705 \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 21 Docs Architecture page in docs \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u2705 20 README Architecture section in README \u2705 \u2705 \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f 19 Diagrams Flowcharts of decision trees \u26a0\ufe0f \u26a0\ufe0f \u274c \u274c \u26a0\ufe0f \u26a0\ufe0f 11 <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p> <p>Maintaining a collection of Architectural Decision Records (ADRs) has been standard practice in industry, beginning the 1990s and popularised by Nygard's 2011 blog post. ADRs are small text files, written in Markdown, that describe the context, the decision, and the consequences of the decision (both good and bad). They ensures a detailed decision history that is human and AI-readable. Several templates for ADRs have been developed and are in use. These vary in the number of sections and level of detail and can be customised. They are easy to maintain and provide the best way to retain history of rationale for decisions but there is a larger effort involved in creating and reviewing them.</p> <p>Informal documentation in the project README or docs requires less effort and is easy to maintain but the history is mostly in the git commits and is harder to find and evaluate by humans. Using the documentation rather than the README makes the information more discoverable.</p> <p>Flowcharts provide a human-friendly visual overview but are more difficult to maintain and not as AI-friendly (although flowcharts as code is AI-friendly and might work well as a supplement if they are kept up-to-date).</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#decision-outcome","title":"Decision Outcome","text":"<p>We will keep a collection of Architectural Decision Records using a template based on MADR, which extends the template proposed by Nygard to include evaluating alternatives, which provides additional valuable knowledge to share with future developers and facilitates a re-evaluation at a later date.</p> <p>The title in the ADR file will use the pattern <code>ADR-NNN: &lt;Verb&gt; &lt;Object&gt; [optional qualifier]</code>, where NNN is a zero padded three digit number (e.g. ADR-001: Use Architectural Decision Records). ADRs will be numbered sequentially and monotonically. Numbers will not be reused.</p> <p>Metadata listed under the title will include: the status of the ADR (\ud83d\udfe1 Proposed, if not yet agreed upon and/or under review / \ud83d\udfe2 Accepted if agreed upon / \ud83d\udd35 Superseded by ADR-NNN if another decision reverses/replaces it), the date created, date last updated, a list of decision-makers and a list of tags.</p> <p>A Context section will describe the forces at play in value-neutral language, stating the facts on the background to a decision.</p> <p>A Problem Statement will summarise the challenge faced and, where possible, articulate it as a clear question to be answered.</p> <p>An Options Considered section will include a decision matrix scoring each of the options considered against the key drivers behind the decision. To avoid false precision, a simple scoring system will be used to rate an option as either good (\u2705), ok (\u26a0\ufe0f) or poor (\u274c). Emoticons will be used to provide human readers with a quick visual overview. These are also readable by current AI tools, such as ChatGPT, and keeping a legend with numerical scoring improves AI-readability. Optional weights will represent the relative importance of drivers and an overall score used to rank the options. A short description will supplement and summarise this decision matrix.</p> <p>The Decision Outcome section states the final decision and the justification based on the results of the decision matrix evaluation. It is stated in full sentences, with active voice.</p> <p>A Consequences section describes the resulting context, after applying the decision. This should describe both the positive and negative impacts of the decision on the project and should also list any unknowns or risks (and optionally what should be done to mitigate these risks).</p> <p>The whole document should be one or two pages long. We will write each ADR as if it is a conversation with a future developer and in a way that maximises its usefulness for AI assistants.</p> <p>We will keep ADRs in the project repository under <code>docs/architecture/adr/</code>. The filename will match the ADR title without the <code>ADR</code> prefix, all lowercase and <code>-</code> replacing spaces, e.g. <code>001-use-architectural-decision-records.md</code>. A template in this directory (<code>template.md</code>) will used for all new ADRs for consistency.</p> <p>If we change a decision at a later date, we will keep the old ADR but mark it as superseded. This way it is available for additional context.</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#consequences","title":"Consequences","text":"<p>Future developers will have clarity over why architecturally significant decisions were made and feel empowered to reverse these decisions as technologies and best practices evolve. AI assistants will gain the context needed to make better suggestions and recommendations. Developers will also benefit from using AI to summarise and explain earlier decisions. This will also be a powerful way to quickly onboard new developers, particularly as the collection of ADRs grows.</p> <p>There will be additional effort required for developers to create and review ADRs but this will pay off in the long-run by reducing the risk of wasting time and effort changing decisions that should not be changed or repeating mistakes that sharing more knowledge would have prevented. Effort can be reduced by using AI assistants to draft and review ADRs (this ADR and the template can be provided as context).</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#confirmation","title":"Confirmation","text":"<p>Developers will be prompted to confirm that they have checked for relevant ADRs when opening a PR. If they are making changes that includes a design choice they will be prompted to create a new ADR with status \"Proposed\", which must be reviewed and accepted before merging any code changes.</p>","tags":["docs"]},{"location":"architecture/adr/001-use-architectural-decision-records/#links","title":"Links","text":"Type Links ADRs Issues PRs","tags":["docs"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/","title":"ADR-002: Manage dependencies with uv","text":"Status \ud83d\udfe2 Accepted Created 2025-10-18 Last Updated 2025-10-18 Deciders Gemma Danks","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#context","title":"Context","text":"<p>Every software project needs a way to manage dependencies. This allows reproducible, consistent installs across operating systems and machines. The Python ecosystem has several options that have evolved over time. It is important to choose a dependency manager that is fast, easy to use in CI, well supported by the community, uses metadata in the pyproject.toml file (i.e. PEP 621 compliant) and provides a good developer experience.</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#problem-statement","title":"Problem Statement","text":"<p>What dependency manager is best for our project?</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#options-considered","title":"Options Considered","text":"Option Description Developer Experience Speed Reproducibility Adoption CI PEP 621 Overall score Notes Weight - 2 2 2 1 1 1 - - uv New, fast replacement for multiple tools, built in Rust by creators of ruff. \u2705 \u2705 \u2705 \u26a0\ufe0f \u2705 \u2705 26 Very fast. Probably the future standard. Also manages python versions. Poetry Well established packaging manager with wide adoption. \u2705 \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 25 Mature, widely used but slower. PDM Light-weight, standards-compliant, written in Python. \u2705 \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 \u2705 24 Good option, not as fast or popular as uv. mamba Reimplementation of conda in C++. \u26a0\ufe0f \u2705 \u2705 \u2705 \u2705 \u274c 23 Fast but not PEP 621 compliant conda Binary package manager, widely used for scientific software. \u26a0\ufe0f \u26a0\ufe0f \u2705 \u2705 \u2705 \u274c 21 Not as fast and not PEP 621 compliant pipenv Simplified packaging management tool. \u26a0\ufe0f \u26a0\ufe0f \u2705 \u26a0\ufe0f \u2705 \u274c 20 Not PEP 621 compliant. pip + venv Standard library tools. \u2705 \u26a0\ufe0f \u274c \u2705 \u2705 \u26a0\ufe0f 20 Not suitable for complex environments spack HPC-oriented packaging manager. Supports full stack. \u274c \u26a0\ufe0f \u2705 \u26a0\ufe0f \u26a0\ufe0f \u274c 17 Best for multi-language environments on HPC clusters. <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#decision-outcome","title":"Decision Outcome","text":"<p>We will use uv since it is extremely fast and likely to become the new standard. It provides a good developer experience and replaces multiple tools. Performance is particularly important for CI. Poetry and PDM are good alternatives. Poetry is more mature and widely adopted.</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#consequences","title":"Consequences","text":"<p>Using uv will simplify Python and dependency management. It is extremely fast and so will speed up continuous integration, reducing waiting time substantially where installing dependencies is the bottleneck. It also manages Python versions and is PEP 621 compliant. This tool is likely to become the new standard.</p> <p>A risk is that this is under active development and is not yet widely adopted. Alternatives to fall back on include Poetry or PDM. This ADR should be revisited in one year since development in this area is ongoing and adoption of particular tools is in a state of flux.</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#confirmation","title":"Confirmation","text":"<p>The project README will document the usage of uv. CI workflows will use uv and the uv.lock file will be placed under version control.</p>","tags":["packaging"]},{"location":"architecture/adr/002-manage-dependencies-with-uv/#links","title":"Links","text":"Type Links ADRs Issues PRs","tags":["packaging"]},{"location":"architecture/adr/template/","title":"ADR-NNN: short title for solved problem and found solution","text":"Status \ud83d\udfe1 Proposed / \ud83d\udfe2 Accepted / \ud83d\udd35 Superseded by ADR-NNN Created YYYY-MM-DD Last Updated YYYY-MM-DD Deciders Name Tags template"},{"location":"architecture/adr/template/#context","title":"Context","text":"<p>Describe the background and constraints written for future human and AI developers.</p>"},{"location":"architecture/adr/template/#problem-statement","title":"Problem Statement","text":"<p>Summarize the main challenge in one or two sentences. Then, phrase the decision explicitly as a question.</p>"},{"location":"architecture/adr/template/#options-considered","title":"Options Considered","text":"<p>Use the table below to evaluate your options against key decision drivers. 1.  Define your drivers \u2014 the forces, constraints, or architectural qualities that matter most (e.g. scalability, maintainability, observability, budget, effort). Add each driver as a column name. 2.  List your options \u2014 add each considered solution as a row. 3. (Optional) Assign weights to drivers to show relative importance. 4.  Describe each option \u2014 one line summary. 5.  Score each option for how well it satisfies each driver using the legend: \u2705 = 3 (Good)\u2003\u26a0\ufe0f = 2 (Acceptable)\u2003\u274c = 1 (Poor) 6.  Compute overall score:</p> <pre><code>overall score = (Driver1 weight \u00d7 Driver1 score)\n              + (Driver2 weight \u00d7 Driver2 score)\n              + ...\n              + (DriverN weight \u00d7 DriverN score)\n</code></pre> <ol> <li>(Optional) Add short notes on the main pros and cons for each option.</li> <li>(Optional) Sort the rows according to the overall score (best fit at the top)</li> </ol> Option Description Driver 1 Driver 2 Driver N Overall score Notes Weight - 1 1 1 - A B C <p>\u2705 = 3 (good), \u26a0\ufe0f = 2 (acceptable), \u274c = 1 (poor)</p>"},{"location":"architecture/adr/template/#decision-outcome","title":"Decision Outcome","text":"<p>We will use Option X because...</p> <p>Justify your choice using the results of the decision matrix above. Describe evidence to support the scoring.</p>"},{"location":"architecture/adr/template/#consequences","title":"Consequences","text":"<ul> <li>Good, because...</li> <li>Bad, because...</li> <li>Unknowns/risks</li> </ul>"},{"location":"architecture/adr/template/#confirmation","title":"Confirmation","text":"<p>How will you ensure this ADR is implemented and enforced?</p>"},{"location":"architecture/adr/template/#links","title":"Links","text":"Type Links ADRs Issues PRs"},{"location":"explanation/","title":"Explanation","text":""},{"location":"how-to/","title":"How-To","text":""},{"location":"reference/","title":"API","text":""},{"location":"reference/#package_name.greet","title":"<code>package_name.greet</code>","text":"<p>Module for greeting users.</p> <p>This module provides functions to greet users.</p> Example <p>from package_name.greet import say_hello say_hello(\"Alice\") 'Hello, Alice!'</p>"},{"location":"reference/#package_name.greet.say_goodbye","title":"<code>say_goodbye(name)</code>","text":"<p>Return a goodbye message.</p> <p>Bids farewell to the user by name.</p> Example <p>say_goodbye(\"Alice\") 'Goodbye, Alice!'</p> Source code in <code>src/package_name/greet.py</code> <pre><code>def say_goodbye(name: str) -&gt; str:\n    \"\"\"Return a goodbye message.\n\n    Bids farewell to the user by name.\n\n    Example:\n        &gt;&gt;&gt; say_goodbye(\"Alice\")\n        'Goodbye, Alice!'\n    \"\"\"\n    return f\"Goodbye, {name}!\"\n</code></pre>"},{"location":"reference/#package_name.greet.say_hello","title":"<code>say_hello(name)</code>","text":"<p>Return a greeting message.</p> <p>Greets the user by name.</p> Example <p>say_hello(\"Alice\") 'Hello, Alice!'</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the person to greet.</p> required <p>Returns:     str: A message to say hello.</p> Source code in <code>src/package_name/greet.py</code> <pre><code>def say_hello(name: str) -&gt; str:\n    \"\"\"Return a greeting message.\n\n    Greets the user by name.\n\n    Example:\n        &gt;&gt;&gt; say_hello(\"Alice\")\n        'Hello, Alice!'\n\n    Args:\n        name (str): The name of the person to greet.\n    Returns:\n        str: A message to say hello.\n    \"\"\"\n    return f\"Hello, {name}!\"\n</code></pre>"},{"location":"tutorials/","title":"Tutorials","text":""}]}